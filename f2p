#!/usr/bin/env python3

import argparse
import os
import sys
import subprocess
import shutil
from functools import lru_cache

MAX_LINE_LENGTH = 2000

class StableArgumentParser(argparse.ArgumentParser):
    """
    ArgumentParser with stable error messages for choices, and without printing usage on errors.
    """

    def error(self, message):
        # Suppress usage block
        self.print_usage = lambda *a, **k: None
        # Print error and exit with code 2
        print(f"{self.prog}: error: {message}", file=sys.stderr)
        sys.exit(1)

    def _check_value(self, action, value):
        # Stable invalid-choice formatting
        if action.choices is not None and value not in action.choices:
            option = action.option_strings[-1] if action.option_strings else action.dest
            choices_str = ", ".join(repr(c) for c in action.choices)
            msg = (
                f"argument {option}: invalid choice: {value!r} "
                f"(choose from {choices_str})"
            )
            self.error(msg)

        return super()._check_value(action, value)


def _classify_text_utf8_file(filepath):
    """
    Classify file for f2p purposes.

    Returns:
      'ok'        - UTF-8 text, all lines <= MAX_LINE_LENGTH
      'not_text'  - not UTF-8 text / could not be read
      'too_long'  - at least one line is longer than MAX_LINE_LENGTH
    """
    try:
        with open(filepath, 'rb') as f:
            data = f.read()
        try:
            text = data.decode('utf-8')
        except UnicodeDecodeError:
            return 'not_text'

        # Exclude files that contain very long lines
        for line in text.splitlines():
            if len(line) > MAX_LINE_LENGTH:
                return 'too_long'

        return 'ok'
    except Exception as e:
        print(f"Error reading file {filepath}: {e}", file=sys.stderr)
        return 'not_text'


def is_text_utf8_file(filepath):
    """
    Return True if file is acceptable for f2p:
      - decodable as UTF-8
      - no line longer than MAX_LINE_LENGTH characters
    """
    return _classify_text_utf8_file(filepath) == 'ok'


@lru_cache(maxsize=None)
def _git_available_and_repo():
    """
    Return True if `git` is available and the current directory is inside a git repo.
    """
    try:
        # Check git is installed
        subprocess.run(["git", "--version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
        # Check we're inside a work tree
        result = subprocess.run(
            ["git", "rev-parse", "--is-inside-work-tree"],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
            check=True
        )
        return result.stdout.strip() == "true"
    except Exception:
        return False

@lru_cache(maxsize=2048)
def is_ignored_by_git(path):
    """
    Return True if the given path is ignored by git (according to .gitignore and standard excludes).
    If git is not available or we're not in a repo, returns False.
    """
    if not _git_available_and_repo():
        return False

    # git expects paths relative to repo root or absolute; relative is fine from cwd.
    # Use --quiet to only rely on exit code: 0 = ignored, 1 = not ignored.
    try:
        # Ensure the path exists or is a prospective path; git check-ignore can handle both
        result = subprocess.run(
            ["git", "check-ignore", "-q", "--", path],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        return result.returncode == 0
    except Exception:
        # On any error, fall back to not ignored
        return False

def find_all_text_files():
    text_files = []
    for root, dirs, files in os.walk('.'):
        # Always skip .git/ folder
        dirs[:] = [d for d in dirs
                   if d != '.git' and not is_ignored_by_git(os.path.join(root, d))]

        for filename in files:
            full_path = os.path.join(root, filename)

            # Skip anything ignored by git (.gitignore / excludes), if applicable
            if is_ignored_by_git(full_path):
                continue

            if os.path.isfile(full_path) and is_text_utf8_file(full_path):
                text_files.append(full_path)
    return sorted(text_files)  # Sort alphabetically

def main():
    parser = StableArgumentParser(
        prog="f2p",
        usage="""

    f2p

or:

    f2p [FILE_OR_DIR ...]
""",
        description=(
"""
Output the contents of UTF-8 text files.

If run without arguments, it recursively finds all UTF-8 text files in the
current directory (respecting .gitignore and excluding .git/).

When writing to a terminal, output goes to the clipboard by default (can be changed with --to).
When piped or redirected, output goes to stdout by default.
"""
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument('files', nargs='*', metavar='FILE_OR_DIR',
                        help='Can be specified zero or more times. Files are output as-is; '
                             'directories are searched recursively for text UTF-8 files, '
                             'respecting .gitignore')
    parser.add_argument(
        '--to',
        choices=['clipboard', 'stdout'],
        default=None,
        help=(
            'Destination for output. When writing to a terminal, the '
            'default is clipboard (pbcopy). When the output is piped or redirected, '
            'the default is stdout.'
        ),
    )

    args = parser.parse_args()

    # If user did not explicitly set --to, choose default based on whether stdout is a TTY.
    # - When writing to a terminal: use clipboard (pbcopy).
    # - When piped/redirected (e.g. `f2p | cat`): use stdout.
    if args.to is None:
        if sys.stdout.isatty():
            args.to = 'clipboard'
        else:
            args.to = 'stdout'

    def find_text_files_under(root_dir):
        collected = []
        for r, dirs, files in os.walk(root_dir):
            # skip .git and ignored dirs
            dirs[:] = [d for d in dirs
                       if d != '.git' and not is_ignored_by_git(os.path.join(r, d))]
            for fn in files:
                fp = os.path.join(r, fn)
                if is_ignored_by_git(fp):
                    continue
                if os.path.isfile(fp) and is_text_utf8_file(fp):
                    collected.append(fp)
        return sorted(collected)

    expanded_paths = []
    if args.files:
        for arg in args.files:
            if not os.path.exists(arg):
                print(f"Error: File does not exist: {arg}", file=sys.stderr)
                sys.exit(1)
            if os.path.isdir(arg):
                # Gather text files under this dir, sorted locally
                expanded_paths.extend(find_text_files_under(arg))
            elif os.path.isfile(arg):
                classification = _classify_text_utf8_file(arg)
                if classification == 'not_text':
                    print(f"Error: File is not a text utf-8 file: {arg}", file=sys.stderr)
                    sys.exit(1)
                if classification == 'too_long':
                    print(
                        f"Error: File has a line longer than {MAX_LINE_LENGTH} characters: {arg}",
                        file=sys.stderr
                    )
                    sys.exit(1)
                expanded_paths.append(arg)
            else:
                print(f"Error: Not a file: {arg}", file=sys.stderr)
                sys.exit(1)
        args.files = expanded_paths

    else:
        args.files = find_all_text_files()
        if not args.files:
            print("Error: No text files found", file=sys.stderr)
            sys.exit(1)

        # Sort auto-found list
        args.files = sorted(args.files)

    total_lines = 0
    total_files = len(args.files)

    # Collect output into buffer first (we must feed pbcopy at once)
    out_lines = []

    for filepath in args.files:
        if os.path.isabs(filepath):
            display_path = filepath
        else:
            display_path = os.path.relpath(filepath)

        out_lines.append(f"## File `{display_path}`\n\n")
        with open(filepath, "r", encoding="utf-8") as f:
            for line in f:
                out_lines.append(line)
                total_lines += 1
        out_lines.append("\n")
        total_lines += 3

    output_text = ''.join(out_lines)

    if args.to == 'clipboard':
        if shutil.which('pbcopy') is None:
            print("Warning: pbcopy not found, writing to stdout instead.", file=sys.stderr)
            sys.stdout.write(output_text)
        else:
            proc = subprocess.Popen(['pbcopy'], stdin=subprocess.PIPE)
            proc.communicate(input=output_text.encode('utf-8'))
    else:
        sys.stdout.write(output_text)

    plural_f = "s" if total_files != 1 else ""
    plural_l = "s" if total_lines != 1 else ""
    print(f"{total_files} file{plural_f}, {total_lines} line{plural_l}", file=sys.stderr)

if __name__ == '__main__':
    main()

