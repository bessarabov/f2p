#!/usr/bin/env python3

import argparse
import os
import sys
import subprocess
from functools import lru_cache

def is_text_utf8_file(filepath):
    try:
        with open(filepath, 'rb') as f:
            data = f.read()
            data.decode('utf-8')
        return True
    except UnicodeDecodeError:
        return False
    except Exception as e:
        print(f"Error reading file {filepath}: {e}", file=sys.stderr)
        return False

@lru_cache(maxsize=None)
def _git_available_and_repo():
    """
    Return True if `git` is available and the current directory is inside a git repo.
    """
    try:
        # Check git is installed
        subprocess.run(["git", "--version"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
        # Check we're inside a work tree
        result = subprocess.run(
            ["git", "rev-parse", "--is-inside-work-tree"],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL,
            text=True,
            check=True
        )
        return result.stdout.strip() == "true"
    except Exception:
        return False

@lru_cache(maxsize=2048)
def is_ignored_by_git(path):
    """
    Return True if the given path is ignored by git (according to .gitignore and standard excludes).
    If git is not available or we're not in a repo, returns False.
    """
    if not _git_available_and_repo():
        return False

    # git expects paths relative to repo root or absolute; relative is fine from cwd.
    # Use --quiet to only rely on exit code: 0 = ignored, 1 = not ignored.
    try:
        # Ensure the path exists or is a prospective path; git check-ignore can handle both
        result = subprocess.run(
            ["git", "check-ignore", "-q", "--", path],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        return result.returncode == 0
    except Exception:
        # On any error, fall back to not ignored
        return False

def find_all_text_files():
    text_files = []
    for root, dirs, files in os.walk('.'):
        # Always skip .git/ folder
        dirs[:] = [d for d in dirs
                   if d != '.git' and not is_ignored_by_git(os.path.join(root, d))]

        for filename in files:
            full_path = os.path.join(root, filename)

            # Skip anything ignored by git (.gitignore / excludes), if applicable
            if is_ignored_by_git(full_path):
                continue

            if os.path.isfile(full_path) and is_text_utf8_file(full_path):
                text_files.append(full_path)
    return sorted(text_files)  # Sort alphabetically

def main():
    parser = argparse.ArgumentParser(
        usage="""

    f2p

or:

    f2p [FILE_OR_DIR ...]
""",
        description=(
"""
Output the contents of text files to STDOUT.

If run without arguments, it recursively finds and outputs
all text UTF-8 files in the current directory, respecting .gitignore
and excluding files under .git/
"""
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument('files', nargs='*', metavar='FILE_OR_DIR',
                        help='Can be specified zero or more times. Files are output as-is; '
                             'directories are searched recursively for text UTF-8 files, '
                             'respecting .gitignore')

    args = parser.parse_args()

    def find_text_files_under(root_dir):
        collected = []
        for r, dirs, files in os.walk(root_dir):
            # skip .git and ignored dirs
            dirs[:] = [d for d in dirs
                       if d != '.git' and not is_ignored_by_git(os.path.join(r, d))]
            for fn in files:
                fp = os.path.join(r, fn)
                if is_ignored_by_git(fp):
                    continue
                if os.path.isfile(fp) and is_text_utf8_file(fp):
                    collected.append(fp)
        return sorted(collected)

    expanded_paths = []
    if args.files:
        for arg in args.files:
            if not os.path.exists(arg):
                print(f"Error: File does not exist: {arg}", file=sys.stderr)
                sys.exit(1)
            if os.path.isdir(arg):
                # Gather text files under this dir, sorted locally
                expanded_paths.extend(find_text_files_under(arg))
            elif os.path.isfile(arg):
                if not is_text_utf8_file(arg):
                    print(f"Error: File is not a text utf-8 file: {arg}", file=sys.stderr)
                    sys.exit(1)
                expanded_paths.append(arg)
            else:
                print(f"Error: Not a file: {arg}", file=sys.stderr)
                sys.exit(1)
        args.files = expanded_paths

    else:
        args.files = find_all_text_files()
        if not args.files:
            print("Error: No text files found", file=sys.stderr)
            sys.exit(1)

        # Sort auto-found list
        args.files = sorted(args.files)

    total_lines = 0
    total_files = len(args.files)

    for filepath in args.files:
        print(f"## File `{os.path.relpath(filepath)}`")
        print()

        with open(filepath, "r", encoding="utf-8") as f:
            for line in f:
                print(line, end="")
                total_lines += 1
        print()
        total_lines += 3

    plural_f = "s" if total_files != 1 else ""
    plural_l = "s" if total_lines != 1 else ""
    print(f"{total_files} file{plural_f}, {total_lines} line{plural_l}", file=sys.stderr)

if __name__ == '__main__':
    main()

